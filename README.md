# TREAZRISLAND

TREAZRISLAND is a self-hosted retro gaming portal that blends a Fastify backend, a Next.js 14 LTS frontend, and SNES-inspired artwork. This repository also contains documentation and infrastructure helpers required to run the stack locally or on a home server.

## Architecture overview

| Layer      | Location          | Summary |
| ---------- | ----------------- | ------- |
| Backend    | `backend/`        | Fastify + Prisma service providing authentication, library management, ROM delivery, and save-state APIs. |
| Frontend   | `frontend/`       | Next.js App Router experience that consumes the backend APIs and renders EmulatorJS locally. |
| Infra      | `infra/`          | Docker Compose definitions and deployment scripts for local and production-like hosting. |
| Docs       | `docs/`           | Product, security, testing, and operations guides referenced throughout the codebase. |

Review the [Product Requirements Document](./TREAZRISLAND_PRD.md) and the [Threat Model](./docs/security/threat-model.md) before making changes that affect behaviour or security posture.

## Prerequisites

- Node.js 22.21.1 LTS and npm 10 (matching the versions generated by the checked-in lockfiles).
- Docker and Docker Compose v2 for containerised dependencies.
- Git LFS if you plan to version large binary assets.

### Pinned LTS baselines

The stack is now aligned with the latest Long Term Support releases and must remain on these versions until explicit approval is granted for an upgrade:

- **Backend:** Fastify 4.29.1 with the Fastify 4-compatible plugin family and Prisma 6.19.0.
- **Frontend:** Next.js 14.2.33 with React 18.3.1 / React DOM 18.3.1 and the matching `eslint-config-next` 14.2.33 toolchain.
- **Runtime:** Node.js 22.21.1 LTS across local development, Docker images, and deployment targets.
- **Infrastructure:** Postgres 16.10-alpine3.22, MinIO RELEASE.2025-09-07T16-13-09Z, MinIO Client RELEASE.2025-08-13T08-35-41Z, Prometheus v3.7.3, Alertmanager v0.29.0, Loki/Promtail 3.5.8, Grafana 12.2.1, Node Exporter v1.10.2, cAdvisor v0.52.1, Cloudflared 2025.11.1, Certbot v5.1.0, and Nginx 1.29.3-alpine3.22.

Do not bump these packages or their transitive LTS peers without written confirmation.

## Environment configuration

1. Copy the template and keep it as the canonical source of truth for local values:

   ```bash
   cp .env.example .env
   ```

2. Reuse the same file everywhere by symlinking it into each package (or copying it if you prefer standalone files):

   ```bash
   ln -s ../.env backend/.env
   ln -s ../.env frontend/.env.local
   ```

   The frontend reads only `NEXT_PUBLIC_*` variables; adjust `NEXT_PUBLIC_API_BASE_URL` if your backend runs on a non-default
   host/port. `NEXT_PUBLIC_API_BASE_URL` and `STORAGE_ENDPOINT` default to `http://localhost` so the stack works without TLS in
   development.

3. Replace all placeholder secrets before exposing the stack to real users. The most important keys are summarised below:

| Area | Keys | Notes |
| ---- | ---- | ----- |
| JWT & sessions | `JWT_SECRET`, `JWT_ACCESS_TTL`, `JWT_REFRESH_TTL` | Use a 32+ character secret in production. TTL values accept [zeit/ms](https://github.com/vercel/ms) format (`15m`, `30d`). |
| Email (SMTP) | `SMTP_HOST`, `SMTP_PORT`, `SMTP_SECURE`, `SMTP_FROM_EMAIL`, optional `SMTP_USERNAME`, `SMTP_PASSWORD`, `SMTP_FROM_NAME`, `SMTP_ALLOW_INVALID_CERTS` | Mandatory when `EMAIL_PROVIDER=smtp`. Disable email features by leaving the provider as `none` only in development. |
| Storage | `STORAGE_DRIVER`, `STORAGE_*` | Set `STORAGE_DRIVER=filesystem` for a simple local path (`STORAGE_LOCAL_ROOT`). For MinIO/S3, fill `ENDPOINT`, `REGION`, `ACCESS_KEY`, `SECRET_KEY`, and bucket names. |
| ScreenScraper | `SCREENSCRAPER_*` | Store plaintext credentials in a secret manager. Use `npm run screenscraper:encrypt` (in `backend/`) to produce the encrypted developer ID/password and commit only the encrypted values. |
| Observability | `LOG_LEVEL`, `METRICS_ENABLED`, `METRICS_TOKEN` | Enable metrics and set a token when scraping `/metrics` from Prometheus. |
| Frontend security | `TREAZ_TLS_MODE` | Environment templates default to `https` to keep HSTS/`upgrade-insecure-requests` enabled. The GitHub runner helpers and Docker entrypoint override to `http` automatically for LAN-only builds. |

Backend configuration is validated on boot by [`backend/src/config/env.ts`](./backend/src/config/env.ts). The process exits with a detailed error message if any required key is missing or malformed.

### HTTP defaults and opting into TLS

- `.env.example` keeps `TREAZ_TLS_MODE=https` so strict HTTPS headers remain the baseline for production deployments.
- The `frontend/scripts/start-http.mjs` helper (used by `npm start`, `npm run start:lan`, and the Docker entrypoint) forces `TREAZ_TLS_MODE=http` when it detects GitHub Actions. Self-hosted runners that promote builds therefore ship LAN-friendly HTTP headers automatically. Export `TREAZ_TLS_MODE=https` before invoking the helper if your preview environment terminates TLS upstream.
- For manual local development you can also set `TREAZ_TLS_MODE=http` (see `scripts/dev-http.sh`) to disable the HTTPS-only headers while working on `http://localhost` or a private LAN host.
  - Point `NEXT_PUBLIC_API_BASE_URL` and `CORS_ALLOWED_ORIGINS` at your `https://` hostname.
  - Update `STORAGE_ENDPOINT` to an HTTPS object-store endpoint (or unset it if your S3-compatible provider enforces TLS automatically).
  - Restart the frontend dev server or rebuild the production bundle so the new security headers take effect.
- Keep the backend and frontend `.env` files in sync (symlinks or shared `TREAZ_ENV_FILE`) so these values propagate through Docker Compose and helper scripts.

## Local development workflow

You can launch both apps with the HTTP defaults in a single terminal via:

```bash
./scripts/dev-http.sh
```

The helper loads `.env.http` (or `.env`) and starts the backend on `http://localhost:3001` and the frontend on
`http://localhost:3000`, printing the URLs for quick access.

### Testing on another device or self-hosted runner

When you need to reach the dev stack from a phone or another machine on your LAN, expose both servers by
configuring the helper with bind addresses and advertised hosts:

1. Copy `.env.example` to `.env.http` (or reuse your main `.env`) and keep `TREAZ_TLS_MODE=http`.
2. Export LAN-specific overrides before launching the helper. The bind addresses control which interfaces the
   servers listen on; the host values tell generated URLs (CORS, API base URL, storage endpoint) which IP/hostname
   to advertise.

   ```bash
   export DEV_HTTP_BACKEND_BIND_ADDRESS=0.0.0.0
   export DEV_HTTP_FRONTEND_BIND_ADDRESS=0.0.0.0
   export DEV_HTTP_BACKEND_HOST=192.168.50.10
   export DEV_HTTP_FRONTEND_HOST=192.168.50.10
   ```

3. Start the stack with `./scripts/dev-http.sh`. The script automatically updates `LISTEN_HOST`, `CORS_ALLOWED_ORIGINS`,
   `NEXT_PUBLIC_API_BASE_URL`, and `STORAGE_ENDPOINT` when they are not already defined.

On a self-hosted GitHub Actions runner, point `TREAZ_HTTP_ENV_FILE` at a checked-in or secure `.env.http` copy and run
the same command under the runner account:

```bash
sudo -u treaz \
  TREAZ_HTTP_ENV_FILE=/opt/treazrisland/config/dev-http.env \
  DEV_HTTP_BACKEND_BIND_ADDRESS=0.0.0.0 \
  DEV_HTTP_FRONTEND_BIND_ADDRESS=0.0.0.0 \
  DEV_HTTP_BACKEND_HOST=192.168.50.10 \
  DEV_HTTP_FRONTEND_HOST=192.168.50.10 \
  /opt/treazrisland/app/scripts/dev-http.sh
```

Replace `192.168.50.10` with the runner's LAN IP so mobile devices can connect without modifying the application code.
If you omit the host overrides, the helper falls back to the runner's primary LAN address when it can detect one, but setting
them explicitly keeps the URLs predictable.

When you promote a build (`npm run build && npm run start`) on an air-gapped server without TLS termination, the new
frontend script forces HTTP automatically, even if `.env` still contains `TREAZ_TLS_MODE=https`:

```bash
cd frontend
npm run start:lan -- --port 3000
```

The helper sets `TREAZ_TLS_MODE=http` automatically (unless you explicitly re-export `https`) while keeping the listener bound to
`0.0.0.0` so phones and tablets on your LAN can load the app over plain HTTP.

For container-based previews (including GitHub Actions runners that publish a Docker image), the production image now ships
with the same helper as its default entrypoint. Build the image and expose it on your LAN with:

```bash
docker build -t treazrisland/frontend ./frontend
docker run --rm -p 3000:3000 treazrisland/frontend
```

Override `TREAZ_TLS_MODE` at runtime (`http` for LAN testing, `https` for hardened deployments) and the helper applies the
correct security headers while binding to `0.0.0.0` for you.

## Self-hosted smoke checks

After configuring your environment file, run a quick end-to-end validation before inviting real players:

1. **Start the stack in HTTP mode for local testing**

   ```bash
   ./scripts/dev-http.sh
   ```

   The script exports sensible defaults (`LISTEN_HOST`, `NEXT_PUBLIC_API_BASE_URL`, `CORS_ALLOWED_ORIGINS`) so the frontend and
   backend agree on URLs. Stop it with `Ctrl+C` after you finish checking the endpoints below.

2. **Verify backend health probes**

   ```bash
   curl -s http://localhost:3001/health/live | jq
   curl -s http://localhost:3001/health/ready | jq
   ```

   A passing readiness report includes `status: "pass"` (or `"warn"` while migrations settle) and lists each component under the
   `components` array. If the response reports `metrics: { status: "fail" }`, double-check that `METRICS_ENABLED` is set correctly
   and that Prometheus can reach the backend from the allowed CIDRs.

3. **Optional: confirm the metrics surface when enabled**

   ```bash
   curl -H "authorization: Bearer ${METRICS_TOKEN}" http://localhost:3001/metrics | head
   ```

   Replace `${METRICS_TOKEN}` with the value from your `.env`. The output should include counters such as
   `treaz_http_request_duration_seconds`. If you receive a `403` or `401`, make sure the curl command is running from an allowed
   IP address and that the token matches the backend configuration.

4. **Tear down the stack**

   When finished, stop the helper (`Ctrl+C`) or run `docker compose -f infra/docker-compose.yml down` if you started the
   containerised stack instead. These steps help self-hosters verify their installation without diving into the codebase.

1. **Start shared services**

   ```bash
   docker compose -f infra/docker-compose.yml up postgres minio
   ```

   The compose file also defines `backend` and `frontend` services; omit them when you want to run the apps directly on your host.

2. **Install backend dependencies and apply database state**

   ```bash
   cd backend
   npm install
   npm run db:prepare
   npm run dev
   ```

   The dev server listens on `http://localhost:3001` by default. Keep this terminal open so Fastify can hot-reload on changes.

3. **Install frontend dependencies and start the Next.js dev server**

   ```bash
   cd frontend
   npm install
   npm run dev
   ```

   Visit `http://localhost:3000` to access the App Router UI. Authentication flows call the backend using the base URL defined in `NEXT_PUBLIC_API_BASE_URL`.

4. **Optional: run everything via Docker Compose**

   ```bash
   docker compose -f infra/docker-compose.yml up --build
   ```

   This command builds the Dockerfiles, loads environment defaults from `.env` (or the file referenced by `TREAZ_ENV_FILE`), and
   launches all services together.

## Quality gates

Follow the [Testing Strategy](./docs/testing/README.md) before opening a pull request. In brief:

- `npm run lint` and `npm test` in both `backend/` and `frontend/`.
- `npm run build` in each package to ensure production bundles compile.
- Optional Playwright smoke tests: `RUN_SMOKE_E2E=1 npm run test:e2e:smoke` from `frontend/` after the stack is running.

## Additional references

- [Infrastructure guide](./infra/README.md)
- [Observability guide](./docs/observability/README.md)
- [Security documentation](./docs/security/README.md)
- [QA baseline gallery](./docs/qa/README.md)

Use the documentation map above to deep-dive into specific features, integrations, or operational procedures.
